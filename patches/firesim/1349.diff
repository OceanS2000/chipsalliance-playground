diff --git a/sim/firesim-lib/src/main/scala/passes/AsyncResetReg.scala b/sim/firesim-lib/src/main/scala/passes/AsyncResetReg.scala
index 961f0388e..5602ca8f2 100644
--- a/sim/firesim-lib/src/main/scala/passes/AsyncResetReg.scala
+++ b/sim/firesim-lib/src/main/scala/passes/AsyncResetReg.scala
@@ -9,7 +9,7 @@ import firrtl.ir._
 import firrtl.Mappers._
 import firrtl.transforms._
 
-class AsyncResetReg extends chisel3.MultiIOModule {
+class AsyncResetReg extends chisel3.Module {
   import chisel3._
   import chisel3.util._
   val en = IO(Input(Bool()))
diff --git a/sim/midas/src/main/scala/midas/FPGAQoRShimGenerator.scala b/sim/midas/src/main/scala/midas/FPGAQoRShimGenerator.scala
index 20d2247f7..9ce63292a 100644
--- a/sim/midas/src/main/scala/midas/FPGAQoRShimGenerator.scala
+++ b/sim/midas/src/main/scala/midas/FPGAQoRShimGenerator.scala
@@ -2,6 +2,7 @@
 package midas.unittest
 
 import chisel3._
+import chisel3.reflect.DataMirror
 
 import freechips.rocketchip.config.{Parameters, Config, Field}
 import midas.widgets.ScanRegister
@@ -16,9 +17,9 @@ class QoRShim(implicit val p: Parameters) extends Module {
 
   val modules = p(QoRTargets)(p)
   val scanOuts = modules.map({ module =>
-    val ports = module.getPorts.flatMap({
-      case chisel3.internal.firrtl.Port(id: Clock, _) => None
-      case chisel3.internal.firrtl.Port(id, _) => Some(id)
+    val ports = DataMirror.modulePorts(module).map(_._2).flatMap({
+      case id: Clock => None
+      case id => Some(id)
     })
     ScanRegister(ports, io.scanEnable, io.scanIn)
   })
diff --git a/sim/midas/src/main/scala/midas/models/sram/AsyncMemModel.scala b/sim/midas/src/main/scala/midas/models/sram/AsyncMemModel.scala
index 4a29f31ea..9b472fc47 100644
--- a/sim/midas/src/main/scala/midas/models/sram/AsyncMemModel.scala
+++ b/sim/midas/src/main/scala/midas/models/sram/AsyncMemModel.scala
@@ -28,7 +28,7 @@ class AsyncMemChiselRTL(val depth: Int, val dataWidth: Int, val nReads: Int = 2,
       case (detected, cmd) => detected || collides(cmd)
     }
 
-    when (write_cmd.active && !reset.asBool() && !collision_detected) {
+    when (write_cmd.active && !reset.asBool && !collision_detected) {
       data.write(write_cmd.addr, write_cmd.data)
     }
   }
@@ -68,7 +68,7 @@ class AsyncMemChiselModel(val depth: Int, val dataWidth: Int, val nReads: Int =
   val active_write_en = Wire(Bool())
   val read_data_async = data.read(active_read_addr)
   val read_data = RegNext(read_data_async)
-  when (active_write_en && !target_reset_value && !reset.asBool()) {
+  when (active_write_en && !target_reset_value && !reset.asBool) {
     data.write(active_write_addr, active_write_data)
   }
 
@@ -110,7 +110,7 @@ class AsyncMemChiselModel(val depth: Int, val dataWidth: Int, val nReads: Int =
 
   // Target reset state management
   channels.reset.ready := !target_reset_fired
-  when (advance_cycle || reset.asBool()) {
+  when (advance_cycle || reset.asBool) {
     target_reset_fired := false.B
   } .elsewhen (channels.reset.fire) {
     target_reset_fired := true.B
@@ -126,7 +126,7 @@ class AsyncMemChiselModel(val depth: Int, val dataWidth: Int, val nReads: Int =
     channels.read_resps(i).bits := Mux(read_state(i) === active, read_data, read_resp_data(i))
     channels.read_resps(i).valid := read_state(i) === active || read_state(i) === generated
 
-    when (advance_cycle || reset.asBool()) {
+    when (advance_cycle || reset.asBool) {
       read_state(i) := start
     } .elsewhen (read_state(i) === start && read_access_granted(i)) {
       read_state(i) := active
@@ -144,7 +144,7 @@ class AsyncMemChiselModel(val depth: Int, val dataWidth: Int, val nReads: Int =
   active_write_en := false.B
   for (i <- 0 until nWrites) {
     channels.write_cmds(i).ready := write_prereqs_met(i) && !write_complete(i)
-    when (advance_cycle || reset.asBool()) {
+    when (advance_cycle || reset.asBool) {
       write_complete(i) := false.B
     } .elsewhen (channels.write_cmds(i).fire) {
       write_complete(i) := true.B
diff --git a/sim/midas/src/main/scala/midas/models/sram/RegfileModel.scala b/sim/midas/src/main/scala/midas/models/sram/RegfileModel.scala
index 47cccfef8..589c53cc4 100644
--- a/sim/midas/src/main/scala/midas/models/sram/RegfileModel.scala
+++ b/sim/midas/src/main/scala/midas/models/sram/RegfileModel.scala
@@ -38,7 +38,7 @@ class RegfileChiselRTL(val depth: Int, val dataWidth: Int, val nReads: Int, val
   val data = Reg(Vec(depth, UInt(dataWidth.W)))
 
   data.foreach({
-    d => when (reset.asBool()) { d := 0.U }
+    d => when (reset.asBool) { d := 0.U }
   })
 
   (channels.read_cmds zip channels.read_resps).foreach({
@@ -46,7 +46,7 @@ class RegfileChiselRTL(val depth: Int, val dataWidth: Int, val nReads: Int, val
   })
 
   channels.write_cmds.foreach({
-    c => when (c.active && !reset.asBool()) { data(c.addr) := c.data }
+    c => when (c.active && !reset.asBool) { data(c.addr) := c.data }
   })
 }
 
@@ -135,7 +135,7 @@ class RegfileChiselModel(val depth: Int, val dataWidth: Int, val nReads: Int, va
     // reset, as it is next-ed during host reset. Regardless, early
     // reset is necessary to guard the first read.
     // Also, only reset after reads are done
-    when (reset.asBool() || (has_reset_token && read_resps_done_next_cycle && reset_token)) {
+    when (reset.asBool || (has_reset_token && read_resps_done_next_cycle && reset_token)) {
       d := 0.U
     }
   }
@@ -146,7 +146,7 @@ class RegfileChiselModel(val depth: Int, val dataWidth: Int, val nReads: Int, va
   // State updates
   val done = read_resps_done_next_cycle && writes_done_next_cycle && has_reset_token
   def updateState(fired: Bool, fire: Bool): Unit = {
-    fired := Mux(reset.asBool() || done, false.B, fired || fire)
+    fired := Mux(reset.asBool || done, false.B, fired || fire)
   }
 
   (reads_cmd_fired zip reads_cmd_fire).foreach { case (fired, fire) => updateState(fired, fire) }
diff --git a/sim/midas/src/test/scala/midas/widgets/ChannelizedHostPortIOSpec.scala b/sim/midas/src/test/scala/midas/widgets/ChannelizedHostPortIOSpec.scala
index 217f163c5..01eccf5d3 100644
--- a/sim/midas/src/test/scala/midas/widgets/ChannelizedHostPortIOSpec.scala
+++ b/sim/midas/src/test/scala/midas/widgets/ChannelizedHostPortIOSpec.scala
@@ -14,7 +14,7 @@ import freechips.rocketchip.config.Parameters
 import midas.widgets._
 
 // Can't elaborate a top-level that is a blackbox, so wrap it
-class BlackBoxWrapper(mod: => BaseModule) extends MultiIOModule {
+class BlackBoxWrapper(mod: => BaseModule) extends Module {
   val testMod = Module(mod)
 }
 
diff --git a/sim/src/main/scala/midasexamples/AssertModule.scala b/sim/src/main/scala/midasexamples/AssertModule.scala
index ac7c99a8a..95023c02a 100644
--- a/sim/src/main/scala/midasexamples/AssertModule.scala
+++ b/sim/src/main/scala/midasexamples/AssertModule.scala
@@ -60,7 +60,7 @@ class DualClockModule extends Module {
   modA.io.pred := io.d
 }
 
-class StimulusGenerator extends MultiIOModule {
+class StimulusGenerator extends Module {
   val input = IO(new Bundle {
     val cycle       = Input(UInt(16.W))
     val pulseLength = Input(UInt(4.W))
diff --git a/sim/src/main/scala/midasexamples/PointerChaser.scala b/sim/src/main/scala/midasexamples/PointerChaser.scala
index 6ae9e53af..81eca841c 100644
--- a/sim/src/main/scala/midasexamples/PointerChaser.scala
+++ b/sim/src/main/scala/midasexamples/PointerChaser.scala
@@ -60,7 +60,7 @@ class PointerChaserDUT(implicit val p: Parameters) extends Module with HasNastiP
 
   when (rFire && memoryIF.r.bits.last){
     resultValid := isFinalNode
-    resultReg := resultReg + memoryIF.r.bits.data.asSInt()
+    resultReg := resultReg + memoryIF.r.bits.data.asSInt
   }.elsewhen (doneFire) {
     resultValid := false.B
     resultReg := 0.S
diff --git a/sim/src/main/scala/midasexamples/PrintfModule.scala b/sim/src/main/scala/midasexamples/PrintfModule.scala
index 141c4b176..b40281544 100644
--- a/sim/src/main/scala/midasexamples/PrintfModule.scala
+++ b/sim/src/main/scala/midasexamples/PrintfModule.scala
@@ -43,7 +43,7 @@ class PrintfModuleDUT(printfPrefix: String = "SYNTHESIZED_PRINT ") extends Modul
   SynthesizePrintf(printf(s"${printfPrefix}CYCLE: %d Char: %c\n", cycle, ch))
 }
 
-class PrintfModuleChild(printfPrefix: String) extends MultiIOModule {
+class PrintfModuleChild(printfPrefix: String) extends Module {
   val c = IO(Input(Bool()))
   val cycle = IO(Input(UInt(16.W)))
 
diff --git a/sim/src/main/scala/midasexamples/TriggerPredicatedPrintf.scala b/sim/src/main/scala/midasexamples/TriggerPredicatedPrintf.scala
index 8dd2960c3..1fe58b081 100644
--- a/sim/src/main/scala/midasexamples/TriggerPredicatedPrintf.scala
+++ b/sim/src/main/scala/midasexamples/TriggerPredicatedPrintf.scala
@@ -28,7 +28,7 @@ class TriggerPredicatedPrintfDUT(printfPrefix: String = "SYNTHESIZED_PRINT ")
 
   val io = IO(new Bundle{})
   // An inner class to reduce namespace bloat in midasexamples package
-  class ChildModule extends MultiIOModule {
+  class ChildModule extends Module {
     val cycle = IO(Input(UInt(16.W)))
     val lfsr = LFSR(16)
 
diff --git a/sim/src/main/scala/midasexamples/TriggerWiringModule.scala b/sim/src/main/scala/midasexamples/TriggerWiringModule.scala
index f2d252bd8..cd091e7fc 100644
--- a/sim/src/main/scala/midasexamples/TriggerWiringModule.scala
+++ b/sim/src/main/scala/midasexamples/TriggerWiringModule.scala
@@ -11,7 +11,7 @@ import chisel3.util._
 
 import scala.collection.mutable
 
-class TriggerSinkModule extends MultiIOModule {
+class TriggerSinkModule extends Module {
   val reference = IO(Input(Bool()))
   // DOC include start: TriggerSink Usage
   // Note: this can be any reference you wish to have driven by the trigger.
@@ -25,7 +25,7 @@ class TriggerSinkModule extends MultiIOModule {
   assert(reference === sinkBool)
 }
 
-class TriggerSourceModule extends MultiIOModule {
+class TriggerSourceModule extends Module {
   val referenceCredit = IO(Output(Bool()))
   val referenceDebit = IO(Output(Bool()))
   private val lfsr = random.LFSR(16)
@@ -46,7 +46,7 @@ class TriggerSourceModule extends MultiIOModule {
   referenceDebit := ~reset.asBool && stop
 }
 
-class LevelSensitiveTriggerSourceModule extends MultiIOModule {
+class LevelSensitiveTriggerSourceModule extends Module {
   val referenceCredit = IO(Output(Bool()))
   val referenceDebit = IO(Output(Bool()))
   private val enable = random.LFSR(16)(0)
@@ -61,7 +61,7 @@ class LevelSensitiveTriggerSourceModule extends MultiIOModule {
   referenceDebit  := enLast && !enable
 }
 
-class ReferenceSourceCounters(numCredits: Int, numDebits: Int) extends MultiIOModule {
+class ReferenceSourceCounters(numCredits: Int, numDebits: Int) extends Module {
   def counterType = UInt(16.W)
   val inputCredits = IO(Input(Vec(numCredits, Bool())))
   val inputDebits  = IO(Input(Vec(numCredits, Bool())))
diff --git a/sim/src/main/scala/midasexamples/TrivialMulticlock.scala b/sim/src/main/scala/midasexamples/TrivialMulticlock.scala
index 5aae3c322..159699d97 100644
--- a/sim/src/main/scala/midasexamples/TrivialMulticlock.scala
+++ b/sim/src/main/scala/midasexamples/TrivialMulticlock.scala
@@ -7,7 +7,7 @@ import freechips.rocketchip.config.Parameters
 
 import midas.widgets.{RationalClockBridge, PeekPokeBridge, RationalClock}
 
-class RegisterModule extends MultiIOModule {
+class RegisterModule extends Module {
   def dataType = UInt(32.W)
   val in = IO(Input(dataType))
   val out = IO(Output(dataType))
diff --git a/sim/src/main/scala/midasexamples/WireInterconnect.scala b/sim/src/main/scala/midasexamples/WireInterconnect.scala
index 3928fb833..91dc261af 100644
--- a/sim/src/main/scala/midasexamples/WireInterconnect.scala
+++ b/sim/src/main/scala/midasexamples/WireInterconnect.scala
@@ -7,7 +7,7 @@ import freechips.rocketchip.config.Parameters
 import chisel3._
 import chisel3.util._
 
-class PipeModule[T <: Data](gen: T, latency: Int = 0) extends MultiIOModule {
+class PipeModule[T <: Data](gen: T, latency: Int = 0) extends Module {
   val in   = IO(Input(gen))
   val out  = IO(Output(gen))
   out := ShiftRegister(in, latency)
