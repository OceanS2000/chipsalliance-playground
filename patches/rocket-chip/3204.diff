diff --git a/src/main/scala/diplomacy/Clone.scala b/src/main/scala/diplomacy/Clone.scala
index bdef46ecf2..aeff91e6c5 100644
--- a/src/main/scala/diplomacy/Clone.scala
+++ b/src/main/scala/diplomacy/Clone.scala
@@ -3,7 +3,7 @@
 package freechips.rocketchip.diplomacy
 
 import Chisel._
-import chisel3.shim.CloneModule
+import chisel3.experimental.CloneModuleAsRecord
 import chisel3.internal.sourceinfo.{SourceInfo}
 
 
@@ -14,7 +14,7 @@ final class CloneLazyModule private (val base: LazyModule)
   def clone[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](node: NodeHandle[DI, UI, EI, BI, DO, UO, EO, BO])(implicit valName: ValName) =
     new MixedTestNode(node, this)
 
-  protected[diplomacy] lazy val io = CloneModule(base.module)
+  protected[diplomacy] lazy val io = CloneModuleAsRecord(base.module)
 }
 
 object CloneLazyModule
diff --git a/src/main/scala/diplomacy/CloneModule.scala b/src/main/scala/diplomacy/CloneModule.scala
index f3a4818c4c..5750eb83ec 100644
--- a/src/main/scala/diplomacy/CloneModule.scala
+++ b/src/main/scala/diplomacy/CloneModule.scala
@@ -19,39 +19,3 @@ class ClonePorts protected[shim](elts: Data*) extends Record
   def apply(field: String) = elements(field)
   override def cloneType = (new ClonePorts(elts: _*)).asInstanceOf[this.type]
 }
-
-class CloneModule private (model: RawModule) extends BlackBox
-{
-  override def desiredName = model.name
-  val io = IO(new ClonePorts(model.getPorts.map(_.id): _*))
-}
-
-object CloneModule
-{
-  def apply(model: BaseModule): ClonePorts = {
-    // Create the 'BlackBox' stand-in
-    val mod = Module(new CloneModule(model.asInstanceOf[RawModule]))
-    // Rewrite the instance definition to be the original module
-    // (this is needed because the original module gets clobbered by DCE + constant prop)
-    val method = classOf[RawModule].getDeclaredMethod("_commands")
-    method.setAccessible(true)
-    val commands = method.invoke(Builder.forcedUserModule).asInstanceOf[ArrayBuffer[Command]]
-    val victimIdx = commands.lastIndexWhere {
-      case DefInstance(_, kill, _) => mod eq kill
-      case _ => false
-    }
-    val victim = commands(victimIdx).asInstanceOf[DefInstance]
-    val standin = new DefInstance(victim.sourceInfo, model, victim.ports) {
-      override def name = victim.name
-    }
-    commands.update(victimIdx, standin)
-    // Wire it up
-    model match {
-      case _: Module =>
-        mod.io("clock") := Module.clock
-        mod.io("reset") := Module.reset
-      case _: RawModule => // Do nothing
-    }
-    mod.io
-  }
-}
