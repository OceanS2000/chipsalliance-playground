diff --git a/src/main/scala/amba/ahb/AHBLite.scala b/src/main/scala/amba/ahb/AHBLite.scala
index 4014ae01046..54426506e91 100644
--- a/src/main/scala/amba/ahb/AHBLite.scala
+++ b/src/main/scala/amba/ahb/AHBLite.scala
@@ -28,8 +28,8 @@ class AHBLite()(implicit p: Parameters) extends LazyModule {
       out.hprot  := in.hprot
       out.haddr  := in.haddr
       out.hwdata := in.hwdata
-      out.hauser :<> in.hauser
-      in.hduser :<> out.hduser
+      out.hauser :<>= in.hauser
+      in.hduser :<>= out.hduser
       in.hrdata := out.hrdata
     }
   }
diff --git a/src/main/scala/amba/ahb/Xbar.scala b/src/main/scala/amba/ahb/Xbar.scala
index 269d5e7f059..06766daeac2 100644
--- a/src/main/scala/amba/ahb/Xbar.scala
+++ b/src/main/scala/amba/ahb/Xbar.scala
@@ -46,7 +46,7 @@ class AHBFanout()(implicit p: Parameters) extends LazyModule {
 
       when (in.hready) { d_sel := a_sel }
       (a_sel zip io_out) foreach { case (sel, out) =>
-        out :<> in
+        out :<>= in
         out.hsel := in.hsel && sel
         out.hmaster.map { _ := 0.U }
       }
diff --git a/src/main/scala/amba/apb/Xbar.scala b/src/main/scala/amba/apb/Xbar.scala
index 1d344e3cbe8..4dd94f16174 100644
--- a/src/main/scala/amba/apb/Xbar.scala
+++ b/src/main/scala/amba/apb/Xbar.scala
@@ -43,7 +43,7 @@ class APBFanout()(implicit p: Parameters) extends LazyModule {
 
       val sel = VecInit(route_addrs.map(seq => seq.map(_.contains(in.paddr)).reduce(_ || _)))
       (sel zip io_out) foreach { case (sel, out) =>
-        out :<> in
+        out :<>= in
         out.psel    := sel && in.psel
         out.penable := sel && in.penable
       }
diff --git a/src/main/scala/amba/axi4/Credited.scala b/src/main/scala/amba/axi4/Credited.scala
index fa20e351d8d..1a7617c5f61 100644
--- a/src/main/scala/amba/axi4/Credited.scala
+++ b/src/main/scala/amba/axi4/Credited.scala
@@ -18,11 +18,11 @@ class AXI4CreditedBuffer(delay: AXI4CreditedDelay)(implicit p: Parameters) exten
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
-      out.aw :<> in.aw.pipeline(delay.aw)
-      out.w :<> in.w.pipeline(delay.w)
-      in.b :<> out.b.pipeline(delay.b)
-      out.ar :<> in.ar.pipeline(delay.ar)
-      in.r :<> out.r.pipeline(delay.r)
+      out.aw :<>= in.aw.pipeline(delay.aw)
+      out.w :<>= in.w.pipeline(delay.w)
+      in.b :<>= out.b.pipeline(delay.b)
+      out.ar :<>= in.ar.pipeline(delay.ar)
+      in.r :<>= out.r.pipeline(delay.r)
     }
   }
 }
@@ -43,11 +43,11 @@ class AXI4CreditedSource(delay: AXI4CreditedDelay)(implicit p: Parameters) exten
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
       val tld = edgeOut.delay
-      out.aw :<> CreditedIO.fromSender(in.aw, tld.aw.total).pipeline(delay.aw)
-      out.w :<> CreditedIO.fromSender(in.w, tld.w.total).pipeline(delay.w)
-      in.b :<> out.b.pipeline(delay.b).toReceiver(tld.b.total)
-      out.ar :<> CreditedIO.fromSender(in.ar, tld.ar.total).pipeline(delay.ar)
-      in.r :<> out.r.pipeline(delay.r).toReceiver(tld.r.total)
+      out.aw :<>= CreditedIO.fromSender(in.aw, tld.aw.total).pipeline(delay.aw)
+      out.w :<>= CreditedIO.fromSender(in.w, tld.w.total).pipeline(delay.w)
+      in.b :<>= out.b.pipeline(delay.b).toReceiver(tld.b.total)
+      out.ar :<>= CreditedIO.fromSender(in.ar, tld.ar.total).pipeline(delay.ar)
+      in.r :<>= out.r.pipeline(delay.r).toReceiver(tld.r.total)
     }
   }
 }
@@ -68,11 +68,11 @@ class AXI4CreditedSink(delay: AXI4CreditedDelay)(implicit p: Parameters) extends
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
       val tld = edgeIn.delay
-      out.aw :<> in.aw.pipeline(delay.aw).toReceiver(tld.aw.total)
-      out.w :<> in.w.pipeline(delay.w).toReceiver(tld.w.total)
-      in.b :<> CreditedIO.fromSender(out.b, tld.b.total).pipeline(delay.b)
-      out.ar :<> in.ar.pipeline(delay.ar).toReceiver(tld.ar.total)
-      in.r :<> CreditedIO.fromSender(out.r, tld.r.total).pipeline(delay.r)
+      out.aw :<>= in.aw.pipeline(delay.aw).toReceiver(tld.aw.total)
+      out.w :<>= in.w.pipeline(delay.w).toReceiver(tld.w.total)
+      in.b :<>= CreditedIO.fromSender(out.b, tld.b.total).pipeline(delay.b)
+      out.ar :<>= in.ar.pipeline(delay.ar).toReceiver(tld.ar.total)
+      in.r :<>= CreditedIO.fromSender(out.r, tld.r.total).pipeline(delay.r)
     }
   }
 }
diff --git a/src/main/scala/amba/axi4/Deinterleaver.scala b/src/main/scala/amba/axi4/Deinterleaver.scala
index eebce524818..459a106949b 100644
--- a/src/main/scala/amba/axi4/Deinterleaver.scala
+++ b/src/main/scala/amba/axi4/Deinterleaver.scala
@@ -47,14 +47,14 @@ class AXI4Deinterleaver(maxReadBytes: Int, buffer: BufferParams = BufferParams.d
       val beats = maxBeats(edgeOut.slave)
 
       // This adapter passes through the AR/AW control + W/B write data channels
-      out.ar :<> in.ar
-      out.aw :<> in.aw
-      out.w :<> in.w
-      in.b :<> out.b
+      out.ar :<>= in.ar
+      out.aw :<>= in.aw
+      out.w :<>= in.w
+      in.b :<>= out.b
 
       // Only the R channel has the possibility of being changed
       if (nothingToDeinterleave(edgeOut.slave)) {
-        in.r.asInstanceOf[ReadyValidIO[AXI4BundleR]] :<> buffer.irrevocable(out.r)
+        in.r.asInstanceOf[ReadyValidIO[AXI4BundleR]] :<>= buffer.irrevocable(out.r)
       } else {
         // We only care to deinterleave ids that are actually in use
         val maxFlightPerId = Seq.tabulate(endId) { i =>
diff --git a/src/main/scala/amba/axi4/Filter.scala b/src/main/scala/amba/axi4/Filter.scala
index bf38b81db82..61dbaad07ac 100644
--- a/src/main/scala/amba/axi4/Filter.scala
+++ b/src/main/scala/amba/axi4/Filter.scala
@@ -32,7 +32,7 @@ class AXI4Filter(
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
-      out :<> in
+      out :<>= in
     }
   }
 }
diff --git a/src/main/scala/amba/axi4/Fragmenter.scala b/src/main/scala/amba/axi4/Fragmenter.scala
index 36d16a76074..ade5f02fd89 100644
--- a/src/main/scala/amba/axi4/Fragmenter.scala
+++ b/src/main/scala/amba/axi4/Fragmenter.scala
@@ -147,7 +147,7 @@ class AXI4Fragmenter()(implicit p: Parameters) extends LazyModule
       val in_w = Queue.irrevocable(in.w, 1, flow=true)
 
       // AR flow control; super easy
-      out.ar :<>: in_ar
+      (out.ar: Data).waiveAll :<>= (in_ar: Data).waiveAll
       out.ar.bits.echo(AXI4FragLast) := ar_last
 
       // When does W channel start counting a new transfer
@@ -161,7 +161,7 @@ class AXI4Fragmenter()(implicit p: Parameters) extends LazyModule
       out.aw.valid := in_aw.valid && (wbeats_ready || wbeats_latched)
       in_aw.ready := out.aw.ready && (wbeats_ready || wbeats_latched)
       wbeats_valid := in_aw.valid && !wbeats_latched
-      out.aw.bits :<>: in_aw.bits
+      (out.aw.bits: Data).waiveAll :<>= (in_aw.bits: Data).waiveAll
       out.aw.bits.echo(AXI4FragLast) := aw_last
 
       // We need to inject 'last' into the W channel fragments, count!
@@ -183,12 +183,12 @@ class AXI4Fragmenter()(implicit p: Parameters) extends LazyModule
 
       // R flow control
       val r_last = out.r.bits.echo(AXI4FragLast)
-      in.r :<> out.r
+      (in.r: Data).waiveAll :<>= (out.r: Data).waiveAll
       in.r.bits.last := out.r.bits.last && r_last
 
       // B flow control
       val b_last = out.b.bits.echo(AXI4FragLast)
-      in.b :<> out.b
+      (in.b: Data).waiveAll :<>= (out.b: Data).waiveAll
       in.b.valid := out.b.valid && b_last
       out.b.ready := in.b.ready || !b_last
 
diff --git a/src/main/scala/amba/axi4/IdIndexer.scala b/src/main/scala/amba/axi4/IdIndexer.scala
index b7650b8e35e..604e60d2341 100644
--- a/src/main/scala/amba/axi4/IdIndexer.scala
+++ b/src/main/scala/amba/axi4/IdIndexer.scala
@@ -60,11 +60,11 @@ class AXI4IdIndexer(idBits: Int)(implicit p: Parameters) extends LazyModule
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
 
       // Leave everything mostly untouched
-      out.ar :<> in.ar
-      out.aw :<> in.aw
-      out.w :<> in.w
-      in.b :<> out.b
-      in.r :<> out.r
+      (out.ar: Data).waiveAll :<>= (in.ar: Data).waiveAll.squeezeAll
+      (out.aw: Data).waiveAll :<>= (in.aw: Data).waiveAll.squeezeAll
+      out.w :<>= in.w
+      (in.b: Data).waiveAll :<>= (out.b: Data).waiveAll.squeezeAll
+      (in.r: Data).waiveAll :<>= (out.r: Data).waiveAll.squeezeAll
 
       val bits = log2Ceil(edgeIn.master.endId) - idBits
       if (bits > 0) {
diff --git a/src/main/scala/amba/axi4/ToTL.scala b/src/main/scala/amba/axi4/ToTL.scala
index 16cf95eb81b..a450b321d7d 100644
--- a/src/main/scala/amba/axi4/ToTL.scala
+++ b/src/main/scala/amba/axi4/ToTL.scala
@@ -110,7 +110,7 @@ class AXI4ToTL(wcorrupt: Boolean)(implicit p: Parameters) extends LazyModule
       r_out.valid := in.ar.valid
       r_out.bits :<= edgeOut.Get(r_id, r_addr, r_size)._2
 
-      r_out.bits.user :<= in.ar.bits.user
+      (r_out.bits.user: Data).waiveAll :<= (in.ar.bits.user: Data).waiveAll
       r_out.bits.user.lift(AMBAProt).foreach { rprot =>
         rprot.privileged :=  in.ar.bits.prot(0)
         rprot.secure     := !in.ar.bits.prot(1)
@@ -146,7 +146,7 @@ class AXI4ToTL(wcorrupt: Boolean)(implicit p: Parameters) extends LazyModule
       w_out.bits :<= edgeOut.Put(w_id, w_addr, w_size, in.w.bits.data, in.w.bits.strb)._2
       in.w.bits.user.lift(AMBACorrupt).foreach { w_out.bits.corrupt := _ }
 
-      w_out.bits.user :<= in.aw.bits.user
+     (w_out.bits.user: Data).waiveAll :<= (in.aw.bits.user: Data).waiveAll
       w_out.bits.user.lift(AMBAProt).foreach { wprot =>
         wprot.privileged :=  in.aw.bits.prot(0)
         wprot.secure     := !in.aw.bits.prot(1)
@@ -182,7 +182,7 @@ class AXI4ToTL(wcorrupt: Boolean)(implicit p: Parameters) extends LazyModule
       ok_r.bits.user :<= out.d.bits.user
 
       // AXI4 needs irrevocable behaviour
-      in.r :<> Queue.irrevocable(ok_r, 1, flow=true)
+      in.r :<>= Queue.irrevocable(ok_r, 1, flow=true)
 
       ok_b.bits.id   := out.d.bits.source >> addedBits
       ok_b.bits.resp := d_resp
diff --git a/src/main/scala/amba/axi4/UserYanker.scala b/src/main/scala/amba/axi4/UserYanker.scala
index 37ee32621f9..49e067d8548 100644
--- a/src/main/scala/amba/axi4/UserYanker.scala
+++ b/src/main/scala/amba/axi4/UserYanker.scala
@@ -56,13 +56,13 @@ class AXI4UserYanker(capMaxFlight: Option[Int] = None)(implicit p: Parameters) e
       val ar_ready = Vec(rqueues.map(_.enq.ready))(arid)
       in .ar.ready := out.ar.ready && ar_ready
       out.ar.valid := in .ar.valid && ar_ready
-      out.ar.bits :<= in .ar.bits
+      (out.ar.bits: Data).waiveAll :<= (in .ar.bits: Data).waiveAll
 
       val rid = out.r.bits.id
       val r_valid = Vec(rqueues.map(_.deq.valid))(rid)
       val r_bits = Vec(rqueues.map(_.deq.bits))(rid)
       assert (!out.r.valid || r_valid) // Q must be ready faster than the response
-      in.r :<> out.r
+      (in.r: Data).waiveAll :<>= (out.r: Data).waiveAll
       in.r.bits.echo :<= r_bits
 
       val arsel = UIntToOH(arid, edgeIn.master.endId).asBools
@@ -77,13 +77,13 @@ class AXI4UserYanker(capMaxFlight: Option[Int] = None)(implicit p: Parameters) e
       val aw_ready = Vec(wqueues.map(_.enq.ready))(awid)
       in .aw.ready := out.aw.ready && aw_ready
       out.aw.valid := in .aw.valid && aw_ready
-      out.aw.bits :<= in .aw.bits
+      (out.aw.bits: Data).waiveAll :<= (in .aw.bits: Data).waiveAll
 
       val bid = out.b.bits.id
       val b_valid = Vec(wqueues.map(_.deq.valid))(bid)
       val b_bits = Vec(wqueues.map(_.deq.bits))(bid)
       assert (!out.b.valid || b_valid) // Q must be ready faster than the response
-      in.b :<> out.b
+      (in.b: Data).waiveAll :<>= (out.b: Data).waiveAll
       in.b.bits.echo :<= b_bits
 
       val awsel = UIntToOH(awid, edgeIn.master.endId).asBools
@@ -94,7 +94,7 @@ class AXI4UserYanker(capMaxFlight: Option[Int] = None)(implicit p: Parameters) e
         q.enq.bits :<= in.aw.bits.echo
       }
 
-      out.w :<> in.w
+      out.w :<>= in.w
     }
   }
 }
diff --git a/src/main/scala/amba/axi4/Xbar.scala b/src/main/scala/amba/axi4/Xbar.scala
index 15c5fc8f45b..d624af7612c 100644
--- a/src/main/scala/amba/axi4/Xbar.scala
+++ b/src/main/scala/amba/axi4/Xbar.scala
@@ -85,7 +85,7 @@ class AXI4Xbar(
     // Transform input bundles
     val in = Wire(Vec(io_in.size, new AXI4Bundle(wide_bundle)))
     for (i <- 0 until in.size) {
-      in(i) :<> io_in(i)
+      in(i) :<>= io_in(i)
 
       // Handle size = 1 gracefully (Chisel3 empty range is broken)
       def trim(id: UInt, size: Int) = if (size <= 1) 0.U else id(log2Ceil(size)-1, 0)
@@ -168,7 +168,7 @@ class AXI4Xbar(
     // Transform output bundles
     val out = Wire(Vec(io_out.size, new AXI4Bundle(wide_bundle)))
     for (i <- 0 until out.size) {
-      io_out(i) :<> out(i)
+      io_out(i) :<>= out(i)
 
       if (io_in.size > 1) {
         // Block AW if we cannot record the W source
diff --git a/src/main/scala/amba/axis/Buffer.scala b/src/main/scala/amba/axis/Buffer.scala
index 5e3d854619b..77ca68f3409 100644
--- a/src/main/scala/amba/axis/Buffer.scala
+++ b/src/main/scala/amba/axis/Buffer.scala
@@ -2,6 +2,7 @@
 
 package freechips.rocketchip.amba.axis
 
+import chisel3._
 import freechips.rocketchip.config._
 import freechips.rocketchip.util._
 import freechips.rocketchip.diplomacy._
@@ -12,7 +13,7 @@ class AXISBuffer(val params: BufferParams)(implicit p: Parameters) extends LazyM
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
-      out :<>: params.irrevocable(in)
+      (out: Data).waiveAll :<>= (params.irrevocable(in): Data).waiveAll
     }
   }
 }
diff --git a/src/main/scala/amba/axis/Xbar.scala b/src/main/scala/amba/axis/Xbar.scala
index c969a675e56..b6797b13b9e 100644
--- a/src/main/scala/amba/axis/Xbar.scala
+++ b/src/main/scala/amba/axis/Xbar.scala
@@ -42,14 +42,14 @@ class AXISXbar(beatBytes: Int, policy: TLArbiter.Policy = TLArbiter.roundRobin)(
     // Transform input bundle sources (dest uses global namespace on both sides)
     val in = Wire(Vec(io_in.size, AXISBundle(wide_bundle)))
     for (i <- 0 until in.size) {
-      in(i) :<> io_in(i)
+      in(i) :<>= io_in(i)
       in(i).bits.lift(AXISId) foreach { _ := io_in(i).bits.id | inputIdRanges(i).start.U }
     }
 
     // Transform output bundle sinks (id use global namespace on both sides)
     val out = Wire(Vec(io_out.size, AXISBundle(wide_bundle)))
     for (o <- 0 until out.size) {
-      io_out(o) :<> out(o)
+      io_out(o) :<>= out(o)
       io_out(o).bits.lift(AXISDest) foreach { _ := trim(out(o).bits.dest, outputIdRanges(o).size) }
     }
 
@@ -77,7 +77,7 @@ object AXISXbar
     if (sources.isEmpty) {
       sink.valid := false.B
     } else if (sources.size == 1) {
-      sink :<> sources.head
+      sink :<>= sources.head
     } else {
       // The number of beats which remain to be sent
       val idle = RegInit(true.B)
diff --git a/src/main/scala/tilelink/Arbiter.scala b/src/main/scala/tilelink/Arbiter.scala
index bf7c238dbce..a5529a0a86d 100644
--- a/src/main/scala/tilelink/Arbiter.scala
+++ b/src/main/scala/tilelink/Arbiter.scala
@@ -68,7 +68,7 @@ object TLArbiter
     applyCancel(policy = policy)(
       sink = sink_ACancel,
       sources = sources_ACancel:_*)
-    sink :<> sink_ACancel.asDecoupled()
+    sink :<>= sink_ACancel.asDecoupled()
   }
 
   def applyCancel[T <: Data](policy: Policy)(sink: ReadyValidCancel[T], sources: (UInt, ReadyValidCancel[T])*): Unit = {
@@ -77,7 +77,7 @@ object TLArbiter
       sink.lateCancel := DontCare
       sink.bits       := DontCare
     } else if (sources.size == 1) {
-      sink :<> sources.head._2
+      sink :<>= sources.head._2
     } else {
       val pairs = sources.toList
       val beatsIn = pairs.map(_._1)
diff --git a/src/main/scala/tilelink/BlockDuringReset.scala b/src/main/scala/tilelink/BlockDuringReset.scala
index 9f7c7db13c8..fe411ef5d63 100644
--- a/src/main/scala/tilelink/BlockDuringReset.scala
+++ b/src/main/scala/tilelink/BlockDuringReset.scala
@@ -5,7 +5,7 @@ package freechips.rocketchip.tilelink
 import chisel3._
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
-import freechips.rocketchip.util.{BlockDuringReset, EnhancedChisel3Assign}
+import freechips.rocketchip.util.{BlockDuringReset}
 
 /** BlockDuringReset ensures that no channel admits to be ready or valid while reset is raised. */
 class TLBlockDuringReset(stretchResetCycles: Int = 0)
@@ -16,12 +16,12 @@ class TLBlockDuringReset(stretchResetCycles: Int = 0)
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
-      out.a :<> BlockDuringReset(in .a, stretchResetCycles)
-      in .d :<> BlockDuringReset(out.d, stretchResetCycles)
+      out.a :<>= BlockDuringReset(in .a, stretchResetCycles)
+      in .d :<>= BlockDuringReset(out.d, stretchResetCycles)
       if (edgeOut.manager.anySupportAcquireB && edgeOut.client.anySupportProbe) {
-        in .b :<> BlockDuringReset(out.b, stretchResetCycles)
-        out.c :<> BlockDuringReset(in .c, stretchResetCycles)
-        out.e :<> BlockDuringReset(in .e, stretchResetCycles)
+        in .b :<>= BlockDuringReset(out.b, stretchResetCycles)
+        out.c :<>= BlockDuringReset(in .c, stretchResetCycles)
+        out.e :<>= BlockDuringReset(in .e, stretchResetCycles)
       } else {
         in.b.valid  := false.B
         in.c.ready  := true.B
diff --git a/src/main/scala/tilelink/Bundle_ACancel.scala b/src/main/scala/tilelink/Bundle_ACancel.scala
index 3a8bf98dba4..2ca079bee4d 100644
--- a/src/main/scala/tilelink/Bundle_ACancel.scala
+++ b/src/main/scala/tilelink/Bundle_ACancel.scala
@@ -21,11 +21,11 @@ class TLBundle_ACancel(val params: TLBundleParameters) extends Record
   /** Down-converts a TLBundle_ACancel to a plain TLBundle, dropping early/late timing split. */
   def asDecoupled(): TLBundle = {
     val out = Wire(new TLBundle(params))
-    out.a :<> a.asDecoupled()
-    b :<> out.b
-    out.c :<> c
-    d :<> out.d
-    out.e :<> e
+    out.a :<>= a.asDecoupled()
+    b :<>= out.b
+    out.c :<>= c
+    d :<>= out.d
+    out.e :<>= e
     out
   }
 
@@ -55,10 +55,10 @@ object TLBundle_ACancel
     out.a.lateCancel := false.B
     out.a.bits := in.a.bits
     in.a.ready := out.a.ready
-    in.b :<> out.b
-    out.c :<> in.c
-    in.d :<> out.d
-    out.e :<> in.e
+    in.b :<>= out.b
+    out.c :<>= in.c
+    in.d :<>= out.d
+    out.e :<>= in.e
     out
   }
 }
diff --git a/src/main/scala/tilelink/Credited.scala b/src/main/scala/tilelink/Credited.scala
index e7b5e6d5a2a..950dc717f20 100644
--- a/src/main/scala/tilelink/Credited.scala
+++ b/src/main/scala/tilelink/Credited.scala
@@ -18,11 +18,11 @@ class TLCreditedBuffer(delay: TLCreditedDelay)(implicit p: Parameters) extends L
   lazy val module = new Impl
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
-      out.a :<> in.a.pipeline(delay.a)
-      in.b :<> out.b.pipeline(delay.b)
-      out.c :<> in.c.pipeline(delay.c)
-      in.d :<> out.d.pipeline(delay.d)
-      out.e :<> in.e.pipeline(delay.e)
+      out.a :<>= in.a.pipeline(delay.a)
+      in.b :<>= out.b.pipeline(delay.b)
+      out.c :<>= in.c.pipeline(delay.c)
+      in.d :<>= out.d.pipeline(delay.d)
+      out.e :<>= in.e.pipeline(delay.e)
     }
   }
 }
@@ -43,11 +43,11 @@ class TLCreditedSource(delay: TLCreditedDelay)(implicit p: Parameters) extends L
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
       val tld = edgeOut.delay
-      out.a :<> CreditedIO.fromSender(in.a, tld.a.total).pipeline(delay.a)
-      in.b :<> Decoupled(out.b.pipeline(delay.b).toReceiver(tld.b.total))
-      out.c :<> CreditedIO.fromSender(in.c, tld.c.total).pipeline(delay.c)
-      in.d :<> Decoupled(out.d.pipeline(delay.d).toReceiver(tld.d.total))
-      out.e :<> CreditedIO.fromSender(in.e, tld.e.total).pipeline(delay.e)
+      out.a :<>= CreditedIO.fromSender(in.a, tld.a.total).pipeline(delay.a)
+      in.b :<>= Decoupled(out.b.pipeline(delay.b).toReceiver(tld.b.total))
+      out.c :<>= CreditedIO.fromSender(in.c, tld.c.total).pipeline(delay.c)
+      in.d :<>= Decoupled(out.d.pipeline(delay.d).toReceiver(tld.d.total))
+      out.e :<>= CreditedIO.fromSender(in.e, tld.e.total).pipeline(delay.e)
     }
   }
 }
@@ -68,11 +68,11 @@ class TLCreditedSink(delay: TLCreditedDelay)(implicit p: Parameters) extends Laz
   class Impl extends LazyModuleImp(this) {
     (node.in zip node.out) foreach { case ((in, edgeIn), (out, edgeOut)) =>
       val tld = edgeIn.delay
-      out.a :<> Decoupled(in.a.pipeline(delay.a).toReceiver(tld.a.total))
-      in.b :<> CreditedIO.fromSender(out.b, tld.b.total).pipeline(delay.b)
-      out.c :<> Decoupled(in.c.pipeline(delay.c).toReceiver(tld.c.total))
-      in.d :<> CreditedIO.fromSender(out.d, tld.d.total).pipeline(delay.d)
-      out.e :<> Decoupled(in.e.pipeline(delay.e).toReceiver(tld.e.total))
+      out.a :<>= Decoupled(in.a.pipeline(delay.a).toReceiver(tld.a.total))
+      in.b :<>= CreditedIO.fromSender(out.b, tld.b.total).pipeline(delay.b)
+      out.c :<>= Decoupled(in.c.pipeline(delay.c).toReceiver(tld.c.total))
+      in.d :<>= CreditedIO.fromSender(out.d, tld.d.total).pipeline(delay.d)
+      out.e :<>= Decoupled(in.e.pipeline(delay.e).toReceiver(tld.e.total))
     }
   }
 }
diff --git a/src/main/scala/tilelink/HintHandler.scala b/src/main/scala/tilelink/HintHandler.scala
index 7b27a7a2148..cb7016f2581 100644
--- a/src/main/scala/tilelink/HintHandler.scala
+++ b/src/main/scala/tilelink/HintHandler.scala
@@ -55,8 +55,8 @@ class TLHintHandler(passthrough: Boolean = true)(implicit p: Parameters) extends
         val mux = Wire(chiselTypeOf(in.a))
 
         repeater.io.repeat := mapPP && !edgeIn.last(out.a)
-        repeater.io.enq :<> in.a
-        out.a :<> mux
+        repeater.io.enq :<>= in.a
+        out.a :<>= mux
 
         // Only some signals need to be repeated
         mux.bits.opcode  := in.a.bits.opcode  // ignored when full
diff --git a/src/main/scala/tilelink/RegisterRouter.scala b/src/main/scala/tilelink/RegisterRouter.scala
index d5d5cb49c00..b03e4b91c44 100644
--- a/src/main/scala/tilelink/RegisterRouter.scala
+++ b/src/main/scala/tilelink/RegisterRouter.scala
@@ -3,7 +3,7 @@
 package freechips.rocketchip.tilelink
 
 import Chisel._
-import chisel3.RawModule
+import chisel3.{RawModule, DontCare}
 import freechips.rocketchip.config.Parameters
 import freechips.rocketchip.diplomacy._
 import freechips.rocketchip.regmapper._
@@ -72,7 +72,7 @@ case class TLRegisterNode(
     in.bits.index := edge.addr_hi(a.bits)
     in.bits.data  := a.bits.data
     in.bits.mask  := a.bits.mask
-    in.bits.extra :<= a.bits.echo
+    (in.bits.extra: Data).waiveAll :<= (a.bits.echo: Data).waiveAll
 
     val a_extra = in.bits.extra(TLRegisterRouterExtra)
     a_extra.source := a.bits.source
@@ -93,7 +93,7 @@ case class TLRegisterNode(
 
     // avoid a Mux on the data bus by manually overriding two fields
     d.bits.data := out.bits.data
-    d.bits.echo :<= out.bits.extra
+    (d.bits.echo: Data).waiveAll :<= (out.bits.extra: Data).waiveAll
     d.bits.opcode := Mux(out.bits.read, TLMessages.AccessAckData, TLMessages.AccessAck)
 
     // Tie off unused channels
diff --git a/src/main/scala/tilelink/ToAHB.scala b/src/main/scala/tilelink/ToAHB.scala
index e6ea042a014..6715d0cf0c4 100644
--- a/src/main/scala/tilelink/ToAHB.scala
+++ b/src/main/scala/tilelink/ToAHB.scala
@@ -205,7 +205,7 @@ class TLToAHB(val aFlow: Boolean = false, val supportHints: Boolean = true, val
       // a_ready and htrans, we add another entry for aFlow=false.
       val depth = if (aFlow) 2 else 3
       val d = Wire(in.d)
-      in.d :<> Queue(d, depth, flow=true)
+      in.d :<>= Queue(d, depth, flow=true)
       assert (!d.valid || d.ready)
 
       val d_flight = RegInit(0.U(2.W))
diff --git a/src/main/scala/tilelink/ToAPB.scala b/src/main/scala/tilelink/ToAPB.scala
index 485fe6b609c..97d1de7ae40 100644
--- a/src/main/scala/tilelink/ToAPB.scala
+++ b/src/main/scala/tilelink/ToAPB.scala
@@ -64,7 +64,7 @@ class TLToAPB(val aFlow: Boolean = true)(implicit p: Parameters) extends LazyMod
       // phase result.  Whenever we have a queued response, we can not allow
       // APB to present new responses, so we must quash the address phase.
       val d = Wire(in.d)
-      in.d :<> Queue(d, 1, flow = true)
+      in.d :<>= Queue(d, 1, flow = true)
 
       // We need an irrevocable input for APB to stall
       val a = Queue(in.a, 1, flow = aFlow, pipe = !aFlow)
diff --git a/src/main/scala/tilelink/ToAXI4.scala b/src/main/scala/tilelink/ToAXI4.scala
index 5e37cb7a7ac..8871189f3e0 100644
--- a/src/main/scala/tilelink/ToAXI4.scala
+++ b/src/main/scala/tilelink/ToAXI4.scala
@@ -148,7 +148,7 @@ class TLToAXI4(val combinational: Boolean = true, val adapterName: Option[String
       val depth = if (combinational) 1 else 2
       val out_arw = Wire(Decoupled(new AXI4BundleARW(out.params)))
       val out_w = Wire(chiselTypeOf(out.w))
-      out.w :<> Queue.irrevocable(out_w, entries=depth, flow=combinational)
+      out.w :<>= Queue.irrevocable(out_w, entries=depth, flow=combinational)
       val queue_arw = Queue.irrevocable(out_arw, entries=depth, flow=combinational)
 
       // Fan out the ARW channel to AR and AW
@@ -174,8 +174,8 @@ class TLToAXI4(val combinational: Boolean = true, val adapterName: Option[String
       arw.cache := 0.U // do not allow AXI to modify our transactions
       arw.prot  := AXI4Parameters.PROT_PRIVILEGED
       arw.qos   := 0.U // no QoS
-      arw.user :<= in.a.bits.user
-      arw.echo :<= in.a.bits.echo
+      (arw.user: Data).waiveAll :<= (in.a.bits.user: Data).waiveAll
+      (arw.echo: Data).waiveAll :<= (in.a.bits.echo: Data).waiveAll
       val a_extra = arw.echo(AXI4TLState)
       a_extra.source := a_source
       a_extra.size   := a_size
@@ -232,9 +232,9 @@ class TLToAXI4(val combinational: Boolean = true, val adapterName: Option[String
       val r_d = edgeIn.AccessAck(r_source, r_size, 0.U, denied = r_denied, corrupt = r_corrupt || r_denied)
       val b_d = edgeIn.AccessAck(b_source, b_size, denied = b_denied)
       r_d.user :<= out.r.bits.user
-      r_d.echo :<= out.r.bits.echo
+      (r_d.echo: Data).waiveAll :<= (out.r.bits.echo: Data).waiveAll
       b_d.user :<= out.b.bits.user
-      b_d.echo :<= out.b.bits.echo
+      (b_d.echo: Data).waiveAll :<= (out.b.bits.echo: Data).waiveAll
 
       in.d.bits := Mux(r_wins, r_d, b_d)
       in.d.bits.data := out.r.bits.data // avoid a costly Mux
diff --git a/src/main/scala/tilelink/Xbar.scala b/src/main/scala/tilelink/Xbar.scala
index a4fad021bfa..6efb8252285 100644
--- a/src/main/scala/tilelink/Xbar.scala
+++ b/src/main/scala/tilelink/Xbar.scala
@@ -235,7 +235,8 @@ object TLXbar_ACancel
       val r = inputIdRanges(i)
 
       if (connectAIO(i).exists(x=>x)) {
-        in(i).a :<> io_in(i).a
+        in(i).a := DontCare
+        (in(i).a: Data).waiveAll :<>= (io_in(i).a: Data).waiveAll
         in(i).a.bits.source := io_in(i).a.bits.source | r.start.U
       } else {
         in(i).a.earlyValid := false.B
@@ -247,8 +248,8 @@ object TLXbar_ACancel
       }
 
       if (connectBIO(i).exists(x=>x)) {
-        io_in(i).b :<> in(i).b
-        io_in(i).b.bits.source := trim(in(i).b.bits.source, r.size)
+        io_in(i).b :<>= in(i).b.squeezeAll
+//        io_in(i).b.bits.source := trim(in(i).b.bits.source, r.size)
       } else {
         in(i).b.ready := true.B
         in(i).b.bits  := DontCare
@@ -257,7 +258,8 @@ object TLXbar_ACancel
       }
 
       if (connectCIO(i).exists(x=>x)) {
-        in(i).c :<> io_in(i).c
+        in(i).c := DontCare
+        (in(i).c: Data).waiveAll :<>= (io_in(i).c: Data).waiveAll
         in(i).c.bits.source := io_in(i).c.bits.source | r.start.U
       } else {
         in(i).c.valid := false.B
@@ -267,8 +269,8 @@ object TLXbar_ACancel
       }
 
       if (connectDIO(i).exists(x=>x)) {
-        io_in(i).d :<> in(i).d
-        io_in(i).d.bits.source := trim(in(i).d.bits.source, r.size)
+        io_in(i).d :<>= in(i).d.squeezeAll
+//        io_in(i).d.bits.source := trim(in(i).d.bits.source, r.size)
       } else {
         in(i).d.ready := true.B
         in(i).d.bits  := DontCare
@@ -277,7 +279,7 @@ object TLXbar_ACancel
       }
 
       if (connectEIO(i).exists(x=>x)) {
-        in(i).e :<> io_in(i).e
+        in(i).e :<>= io_in(i).e
       } else {
         in(i).e.valid := false.B
         in(i).e.bits  := DontCare
@@ -292,7 +294,7 @@ object TLXbar_ACancel
       val r = outputIdRanges(o)
 
       if (connectAOI(o).exists(x=>x)) {
-        io_out(o).a :<> out(o).a
+        (io_out(o).a: Data).waiveAll :<>= (out(o).a: Data).waiveAll.squeezeAll
       } else {
         out(o).a.ready      := true.B
         out(o).a.lateCancel := DontCare
@@ -303,7 +305,7 @@ object TLXbar_ACancel
       }
 
       if (connectBOI(o).exists(x=>x)) {
-        out(o).b :<> io_out(o).b
+        out(o).b :<>= io_out(o).b
       } else {
         out(o).b.valid := false.B
         out(o).b.bits  := DontCare
@@ -312,7 +314,7 @@ object TLXbar_ACancel
       }
 
       if (connectCOI(o).exists(x=>x)) {
-        io_out(o).c :<> out(o).c
+        io_out(o).c :<>= out(o).c.squeezeAll
       } else {
         out(o).c.ready := true.B
         out(o).c.bits  := DontCare
@@ -321,7 +323,7 @@ object TLXbar_ACancel
       }
 
       if (connectDOI(o).exists(x=>x)) {
-        out(o).d :<> io_out(o).d
+        out(o).d :<>= io_out(o).d
         out(o).d.bits.sink := io_out(o).d.bits.sink | r.start.U
       } else {
         out(o).d.valid := false.B
@@ -331,7 +333,7 @@ object TLXbar_ACancel
       }
 
       if (connectEOI(o).exists(x=>x)) {
-        io_out(o).e :<> out(o).e
+        io_out(o).e :<>= out(o).e
         io_out(o).e.bits.sink := trim(out(o).e.bits.sink, r.size)
       } else {
         out(o).e.ready := true.B
diff --git a/src/main/scala/util/package.scala b/src/main/scala/util/package.scala
index 3f36b138715..a842b2bf6eb 100644
--- a/src/main/scala/util/package.scala
+++ b/src/main/scala/util/package.scala
@@ -286,59 +286,4 @@ package object util {
     case x if x == n => in
     case _ => throw new Exception(s"must provide exactly 1 or $n of some field, but got:\n$in")
   }
-
-/** provides operators useful for working with bidirectional [[Bundle]]s
-  * 
-  * In terms of [[Flipped]] with a producer 'p' and 'consumer' c:
-  * c :<= p // means drive all unflipped fields of 'c' from 'p' (e.g.: c.valid := p.valid)
-  * c :=> p // means drive all flipped fields of 'p' from 'c' (e.g.: `p.ready := c.ready`)
-  * c :<> p // do both of the above
-  * p :<> c // do both of the above, but you'll probably get a Flow error later.
-  * 
-  * This utility class is needed because in [[chisel3]]:
-  * c := p // only works if there are no directions on fields.  
-  * c <> p // only works if one of those is an [[IO]] (not a [[Wire]]).
-  * 
-  * Compared with [[chisel3]] operators:
-  * c <> p   is an 'actual-direction'-inferred 'c :<> p' or 'p :<> c'
-  * c := p is equivalent to 'c :<= p' + 'p :=> c'. In other words, drive ALL fields of 'c' from 'p' regardless of their direction.
-  * 
-  * Contrast this with 'c :<> p' which will connect a ready-valid producer
-  * 'p' to a consumer 'c'.
-  * If you flip this to 'p :<> c', it works the way you would expect (flipping the role of producer/consumer).
-  * This is how Chisel._ (compatability mode) and firrtl work.
-  * Some find that  ':<>' has superior readability (even if the direction can be inferred from an IO),
-  * because it clearly states the intended producer/consumer relationship. 
-  * You will get an appropriate error if you connected it the wrong way
-  * (usually because you got the IO direction wrong) instead of silently succeeding.
-  * 
-  * What if you want to connect all of the signals (e.g. ready/valid/bits)
-  * from producer 'p' to a monitor 'm'?
-  * For example in order to tap the connection to monitor traffic on an existing connection.
-  * In that case you can do 'm :<= p' and 'p :=> m'.
-  */
-  implicit class EnhancedChisel3Assign[T <: Data](private val x: T) extends AnyVal {
-    /** Assign all output fields of x from y; note that the actual direction of x is irrelevant */
-    def :<= (y: T): Unit = FixChisel3.assignL(x, y)
-    /** Assign all input fields of y from x; note that the actual direction of y is irrelevant */
-    def :=> (y: T): Unit = FixChisel3.assignR(x, y)
-    /** Bulk connect which will work between two [[Wire]]s (in addition to between [[IO]]s) */
-    def :<> (y: T): Unit = {
-      FixChisel3.assignL(x, y)
-      FixChisel3.assignR(x, y)
-    }
-
-
-    // Versions of the operators that use the type from the RHS
-    // y :<=: x  ->  x.:<=:(y)  ->  y :<= x  ->  FixChisel3.assignL(y, x)
-    /** version of the :<= operator that uses the type from the RHS */
-    def :<=: (y: T): Unit = { FixChisel3.assignL(y, x) }
-    /** version of the :=> operator that uses the type from the RHS */
-    def :>=: (y: T): Unit = { FixChisel3.assignR(y, x) }
-    /** version of the :<> operator that uses the type from the RHS */
-    def :<>: (y: T): Unit = {
-      FixChisel3.assignL(y, x)
-      FixChisel3.assignR(y, x)
-    }
-  }
 }
